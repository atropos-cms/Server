type User {
    id: ID!
    first_name: String
    last_name: String
    initials: String
    street: String
    postcode: String
    city: String
    country: String
    email: String!
    created_at: DateTime!
    updated_at: DateTime!
    deleted_at: DateTime

    permissions: [Permission!]!  @method(name: "getAllPermissions")
    directPermissions: [Permission!]!  @method(name: "getDirectPermissions")
    inheritedPermissions: [Permission!]! @method(name: "getPermissionsViaRoles")
    roles: [Role!]!
}

input UpdateUserInput {
    first_name: String @rules(apply: ["string"])
    last_name: String @rules(apply: ["string"])
    street: String
    postcode: String
    city: String
    country: String
    email: String @rules(apply: ["email", "unique:users,email"])
    password: String @bcrypt
}

input CreateUserInput {
    first_name: String @rules(apply: ["string"])
    last_name: String @rules(apply: ["string"])
    street: String
    postcode: String
    city: String
    country: String
    email: String @rules(apply: ["required", "email", "unique:users,email"])
    password: String @bcrypt
}


extend type Query @middleware(checks: ["auth:api"]) {
    me: User @auth
    user(id: ID! @eq): User @find
    users(search: String @search): [User!]! @paginate @softDeletes
}

extend type Mutation @middleware(checks: ["auth:api"]) {
    updateMe(data: UpdateUserInput! @spread): User
        @broadcast(subscription: "userUpdated")

    createUser(data: CreateUserInput! @spread): User @create
    updateUser(id: ID!, data: UpdateUserInput! @spread): User @update
    deleteUser(id: ID!): User @delete
    restoreUser(id: ID!): User @restore
}

type Subscription {
    userUpdated(id: ID): User
}
